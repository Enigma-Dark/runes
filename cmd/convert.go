package cmd

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"

	"github.com/Enigma-Dark/runes/internal/files"
	"github.com/Enigma-Dark/runes/internal/generator"
	"github.com/Enigma-Dark/runes/internal/output"
	"github.com/Enigma-Dark/runes/internal/replay"
	"github.com/Enigma-Dark/runes/internal/types"
)

var (
	outputFile   string
	contractName string
	testName     string
	templateName string
)

// convertCmd represents the convert command
var convertCmd = &cobra.Command{
	Use:   "convert [reproducer-file-or-directory]",
	Short: "Convert an Echidna reproducer file to a Foundry test",
	Long: `Convert an Echidna reproducer .txt file to a Foundry test file.

The reproducer file should be a JSON array of transactions generated by Echidna.
You can provide either a specific .txt file or a directory containing .txt files.
When a directory is provided, files are grouped by creation time and the newest 
group is processed, generating one test function per .txt file in that group.

This command will parse the file(s) and generate corresponding Foundry test functions.

Example:
  runes convert reproducer.txt --output ReplayTest.t.sol --contract ReplayTest --test testReplay
  runes convert /path/to/reproducers/ --output ReplayTest.t.sol`,
	Args: cobra.ExactArgs(1),
	RunE: runConvert,
}

func init() {
	rootCmd.AddCommand(convertCmd)
	convertCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path or directory (if directory, auto-generates incrementing names like ReplayTest_1.t.sol)")
	convertCmd.Flags().StringVarP(&contractName, "contract", "c", "", "Contract name (default: [input-name]Replay or ReplayTestN)")
	convertCmd.Flags().StringVarP(&testName, "test", "t", "", "Test function name (deprecated - auto-generated for groups)")
	convertCmd.Flags().StringVarP(&templateName, "template", "", "enigmadark", "Template to use: 'basic', 'enigmadark', or path to custom .tmpl file")
}

// runConvert is the main convert command logic
func runConvert(cmd *cobra.Command, args []string) error {
	inputPath := args[0]

	// Discover replay files
	replayFiles, err := files.DiscoverReplayFiles(inputPath)
	if err != nil {
		return fmt.Errorf("failed to resolve input files: %w", err)
	}

	// Process files into replay groups
	allReplays, err := replay.ProcessFiles(replayFiles)
	if err != nil {
		return err
	}

	// Resolve output configuration
	config := resolveOutputConfig(replayFiles, allReplays)

	// Extract number from output filename and update test names
	number := extractNumberFromFilename(config.OutputFile)
	if number != "" {
		for i := range allReplays {
			functionName, _ := replay.GenerateTestFunctionName(allReplays[i].FileName, number, allReplays[i].Calls)
			allReplays[i].TestName = functionName
		}
	}

	// Generate the test file
	if err := generator.GenerateFoundryTest(config); err != nil {
		return fmt.Errorf("failed to generate test file: %w", err)
	}

	printSuccessInfo(config, len(allReplays))
	return nil
}

// printProcessingInfo displays information about files being processed
func printProcessingInfo(replayFiles []files.FileInfo) {
	if len(replayFiles) == 1 {
		fmt.Printf("Processing single file: %s\n", replayFiles[0].Path)
	} else {
		fmt.Printf("Processing %d files from newest group (created at %s):\n",
			len(replayFiles), replayFiles[0].ModTime.Format("2006-01-02 15:04:05"))
		for _, file := range replayFiles {
			fmt.Printf("  - %s\n", filepath.Base(file.Path))
		}
	}
}

// resolveOutputConfig determines output file and contract name
func resolveOutputConfig(replayFiles []files.FileInfo, allReplays []types.ReplayGroup) generator.GenerateConfig {
	isMultiple := len(replayFiles) > 1

	// Resolve output file
	resolvedOutput := outputFile
	if resolvedOutput == "" {
		if isMultiple {
			resolvedOutput = "grouped_replays.t.sol"
		} else {
			base := strings.TrimSuffix(filepath.Base(replayFiles[0].Path), filepath.Ext(replayFiles[0].Path))
			resolvedOutput = fmt.Sprintf("%s_replay.t.sol", base)
		}
	}

	resolvedOutput = output.ResolveOutputPath(resolvedOutput, isMultiple)

	// Resolve contract name
	resolvedContract := contractName
	if resolvedContract == "" {
		resolvedContract = output.GenerateContractName(resolvedOutput, "ReplayTest")
	}

	return generator.GenerateConfig{
		ContractName: resolvedContract,
		OutputFile:   resolvedOutput,
		ReplayGroups: allReplays,
		Template:     templateName,
	}
}

// printSuccessInfo displays success information
func printSuccessInfo(config generator.GenerateConfig, testCount int) {
	fmt.Printf("Successfully generated Foundry test: %s\n", config.OutputFile)
	fmt.Printf("Contract name: %s\n", config.ContractName)
	fmt.Printf("Generated %d test functions\n", testCount)
}

// extractNumberFromFilename extracts the number from ReplayTest_X pattern
func extractNumberFromFilename(filename string) string {
	baseName := strings.TrimSuffix(filepath.Base(filename), filepath.Ext(filename))
	baseName = strings.TrimSuffix(baseName, ".t")

	if strings.Contains(baseName, "ReplayTest_") {
		parts := strings.Split(baseName, "_")
		if len(parts) >= 2 {
			return parts[1]
		}
	}
	return ""
}
